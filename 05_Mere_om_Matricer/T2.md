# Tutorial 2: Ortogonale Matricer

Vi har allerede tyvstartet p친 ortogonale matricer i tidligere sessioner, hvor vi placerede vektorer i matricer for at tjekke, om de var ortogonale. Dette gjorde vi, da det var nemmere end at tjekke alle prikprodukter. I denne tutorial vil vi se p친, hvad det betyder for en matrix at v칝re ortogonal.

Ortogonale matricer er en vigtig klasse af matricer, der har en r칝kke nyttige egenskaber, is칝r inden for 3D-grafik og line칝re transformationer. Denne tutorial vil udforske disse matricer i detaljer, inklusive forskellen mellem ortogonalitet og ortonormalitet, og hvordan man ortogonaliserer en matrix.

---

## Definition af en Ortogonal Matrix
En kvadratisk matrix \( \mathbf{M} \) er **ortogonal**, hvis og kun hvis produktet af matricen og dens transponerede er lig med identitetsmatricen \( \mathbf{I} \):

\[
\mathbf{M}\mathbf{M}^T = \mathbf{I}
\]

Dette er 칝kvivalent med at sige, at den transponerede af \( \mathbf{M} \) er lig med dens inverse:

\[
\mathbf{M}^T = \mathbf{M}^{-1}
\]

Denne egenskab er s칝rlig v칝rdifuld, da den g칮r det **meget nemmere at beregne den inverse** af en ortogonal matrix, da man blot kan transponere den.

## Gram-matricen og dens betydning

N친r vi arbejder med ortogonale matricer, er **Gram-matricen** et nyttigt v칝rkt칮j til at analysere relationerne mellem en matrix' s칮jler eller r칝kker. 

Gram-matricen for en matrix \( \mathbf{M} \) defineres som:

\[
\mathbf{G} = \mathbf{M}^T \mathbf{M}
\]

Dette betyder, at **Gram-matricen indeholder alle prikprodukter mellem s칮jlerne i \( \mathbf{M} \)**. 

### Egenskaber ved Gram-matricen
- Hvis \( \mathbf{G} \) er **diagonal**, betyder det, at s칮jlerne i \( \mathbf{M} \) er **ortogonale**.
- Hvis \( \mathbf{G} \) er **identitetsmatricen**, er s칮jlerne i \( \mathbf{M} \) b친de **ortogonale og normaliserede**, dvs. \( \mathbf{M} \) er **ortonormal**.
- Gram-matricen bruges ogs친 i metoder som **Gram-Schmidt-ortogonalisering** og i **mindste kvadraters metode** i statistik og machine learning.

游눠 Hvis en matrix er ortogonal, vil dens Gram-matrix v칝re diagonal, men ikke n칮dvendigvis identitetsmatricen. Dette betyder, at ortogonale matricer kan indeholde skalering, mens ortonormale matricer ikke g칮r.

### 游눹 Beregning af Gram-matricen
```python
import numpy as np

# Definer en matrix
M = np.array([[3, 0],
              [0, 2]])

# Beregn Gram-matricen
G = M.T @ M

print("Gram-matrix:\n", G)
```

### 游눹 Tjek om en matrix er ortogonal (med tolerance)
```python
import numpy as np

M = np.array([[0, -2, 0],
              [5, 0, 0],
              [0, 0, 3]])

G = M.T @ M  # Gram-matricen

tolerance = 1e-4  # Definer tolerance for numerisk pr칝cision
    
# Tjek om G er diagonal (alle ikke-diagonale elementer skal v칝re t칝t p친 0)
is_orthogonal = np.allclose(G - np.diag(np.diagonal(G)), 0, atol=tolerance)

# print
print("Er matricen ortogonal?", is_orthogonal)
```
游댳 **Bem칝rk**: P친 grund af floating-point afrundingsfejl bruger vi en **tolerance p친 \(10^{-4}\)**, n친r vi sammenligner med identitetsmatricen. Du kan 칝ndre tolerancen ved at justere `tolerance`-variablen.

### 游눹 Tjek om en matrix er ortonormal (med tolerance)
```python
import numpy as np

# Definer en matrix
M = np.array([[0.7071,0.5,0.5],
              [-0.7071,0.5,0.5],
              [0.0,-0.7071,0.7071]])

tolerance = 1e-4  # Definer tolerance for numerisk pr칝cision

# Tjek om M er ortogonal ved at sammenligne med identitetsmatricen
# Bem칝rk Gram matricen beregnes som M @ M.T
is_orthonormal = np.allclose(M @ M.T, np.eye(3), atol=tolerance)

print("Er matricen ortonormal?", is_orthonormal)
```

---

## Geometrisk fortolkning
Ortogonale matricer repr칝senterer transformationer, der **bevarer l칝ngder og vinkler**. De omfatter:

- **Rotationer**: Roterer rummet omkring en akse.
- **Refleksioner**: Spejler rummet omkring en akse eller et plan.

### 游눹 En rotationsmatrix om z-aksen
```python
import numpy as np

theta = np.radians(45)  # Rotation p친 45 grader
R = np.array([[np.cos(theta), -np.sin(theta), 0],
              [np.sin(theta),  np.cos(theta), 0],
              [0, 0, 1]])

# Tjek om R er ortogonal med tolerance
tolerance = 1e-4
print("Er rotationsmatricen ortogonal?", np.allclose(R @ R.T, np.eye(3), atol=tolerance))
```

---

## Gram-Schmidt Ortogonalisering
Givet en basis af vektorer \( \mathbf{r}_1, \mathbf{r}_2, ..., \mathbf{r}_n \), konstruerer Gram-Schmidt en ortogonal basis:

### 游눹 Implementering af Gram-Schmidt
```python
def gram_schmidt(X):
    """ Udf칮rer Gram-Schmidt ortogonalisering p친 s칮jlerne af X """
    Q = np.zeros_like(X, dtype=float)
    for i in range(X.shape[1]):
        q = X[:, i]
        for j in range(i):
            q -= np.dot(Q[:, j], X[:, i]) * Q[:, j]
        q /= np.linalg.norm(q)
        Q[:, i] = q
    return Q

# Definer en matrix med line칝rt uafh칝ngige vektorer
A = np.array([[3, 1],
              [2, 2],
              [2, 3]], dtype=float)

Q = gram_schmidt(A)
print("Ortogonaliseret matrix:\n", Q)
print("Er den ortonormal?", np.allclose(Q.T @ Q, np.eye(Q.shape[1]), atol=1e-4))
```

---

## Konklusion
- En **ortogonal matrix** opfylder \( \mathbf{M}^T = \mathbf{M}^{-1} \).
- **Ortonormale matricer** har s칮jler/r칝kker, der er b친de ortogonale og normaliserede.
- **Gram-Schmidt** er en nyttig metode til at ortogonalisere vektorer.
- **Ortogonale matricer bevarer l칝ngder og vinkler** og bruges bl.a. til 3D-transformationer.
- Vi bruger en tolerance p친 **\(10^{-4}\)** for at tage h칮jde for floating-point afrundingsfejl. V칝rdien kan s칝ttes op eller ned efter behov.
