# Tutorial 3: Homogene matricer og translationer
Homogene matricer er 4x4 matricer, der bruges til at repr√¶sentere affine transformationer i 3D-rum. Dette inkluderer **translation, rotation, skalering, shear og perspektivisk projektion**.

En generel 4x4 transformationsmatrix ser s√•ledes ud:

$$
\mathbf{M} = \begin{bmatrix}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
t_x & t_y & t_z & 1
\end{bmatrix}
$$

Hvor:

*   $r_{ij}$ repr√¶senterer elementerne i en 3x3 rotationsmatrix (eller en anden line√¶r transformation).
*   $t_x, t_y, t_z$ repr√¶senterer translationen i x-, y- og z-retningen.

I bogen notation repr√¶senteres translationen i den **nederste r√¶kke** af matricen, hvor den vektor, der skal transformeres, er en **r√¶kkevektor** der ganges fra venstre. I videoerne repr√¶senteres translationen i den **sidste s√∏jle** af matricen, hvor vektoren, der skal transformeres, er en **s√∏jlevektor** der ganges fra h√∏jre. Dette er ogs√• den mest almindelige konvention.

## üí° Notation: R√¶kkevektorer vs. S√∏jlevektorer

N√•r vi arbejder med homogene koordinater, kan vi v√¶lge at repr√¶sentere punkter som:

1. **R√¶kkevektorer**: \(\mathbf{p} = \begin{bmatrix} x & y & z & 1 \end{bmatrix}\)  
    - Her multiplicerer vi matricen fra h√∏jre: \(\mathbf{p}' = \mathbf{p} \mathbf{M}\)

2. **S√∏jlevektorer**: \(\mathbf{p} = \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}\)  
    - Her multiplicerer vi matricen fra venstre: \(\mathbf{p}' = \mathbf{M} \mathbf{p}\)

Vi bruger som bekendt et venstreh√•ndet system, hvor \( y \)-aksen peger op, men formlerne √¶ndrer sig afh√¶ngigt af, om vi bruger r√¶kke- eller s√∏jlevektorer. I sidste emne pr√¶senterede vi transformationer i 2D og 3D, hvor vi brugte s√∏jlevektorer - vi fulgte bogens konvention. Men n√•r det kommer til translationer og homogene matricer, skifter bogen om til *r√¶kkevektorer*. Det er lidt tr√¶ls og kan skabe forvirring. Men heldigvis er det ret simpelt at konvertere mellem de to konventioner:

‚úî **Forskellen mellem r√¶kke- og s√∏jlevektorer er, at alle transformationer transponeres!**  

Bem√¶rk, der kan ogs√• v√¶re lidt tvivl om hvad der menes med at gange fra h√∏jre eller venstre. Lad os sige vi har en vektor \(\mathbf{v}\) og en matrix \(\mathbf{M}\). Hvis vi skriver \(\mathbf{v} \mathbf{M}\), betyder det at vi ganger vektoren fra h√∏jre med matricen. Hvis vi skriver \(\mathbf{M} \mathbf{v}\), betyder det at vi ganger vektoren fra venstre med matricen. Men n√•r der er tale om transformationer, skriver man ofte at transformationen anvendes p√• vektoren fra h√∏jre, fx $\mathbf{p}' = \mathbf{p} \mathbf{M}$, selvom det i praksis betyder at vi ganger vektoren fra venstre med matricen.


## 2D Transformationer i 3D

Selvom disse transformationer er 2D, kan de alts√• repr√¶senteres i 3D ved at inkludere dem i en 3D homogen matrix for s√∏jlevektorer:

*   **2D Rotation om Origo:**

    $$
    \mathbf{R}(Œ∏)_{\text{s√∏jle}} = \begin{bmatrix}
    \cos Œ∏ & \sin Œ∏ & 0 \\
    -\sin Œ∏ & \cos Œ∏ & 0 \\
    0 & 0 & 1
    \end{bmatrix}
    $$

*   **2D Skalering langs akserne:**

    $$
    \mathbf{S}(k_x, k_y) = \begin{bmatrix}
    k_x & 0 & 0 \\
    0 & k_y & 0 \\
    0 & 0 & 1
    \end{bmatrix}
    $$

For r√¶kkevektorer, skal du transponere matricen:

*   **2D Rotation om Origo:**

    $$
    \mathbf{R}(Œ∏)_{\text{r√¶kke}} = \begin{bmatrix}
    \cos Œ∏ & -\sin Œ∏ & 0 \\
    \sin Œ∏ & \cos Œ∏ & 0 \\
    0 & 0 & 1
    \end{bmatrix}
    $$

*   **2D Skalering langs akserne:** Ingen √¶ndring



## **1Ô∏è‚É£ Translation**
En **translation** forskyder et punkt i rummet med \( (t_x, t_y, t_z) \). For en 3D translation af s√∏jlevektorer bruger vi en 4x4 matrix:

\[
\mathbf{T} =
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1
\end{bmatrix}
\]

Multiplikation af et punkt $(x, y, z, 1)$ med $\mathbf{T}$ giver:

\[
\begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} \mathbf{T} =
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1
\end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix}  = \begin{bmatrix} x + t_x \\ y + t_y \\ z + t_z \\ 1 \end{bmatrix}
\]


Og til r√¶kkevektorer bruger vi den transponerede version:

$$
\mathbf{T} = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
t_x & t_y & t_z & 1
\end{bmatrix}
$$

Multiplikation af et punkt $(x, y, z, 1)$ med $\mathbf{T}$ giver:

$$
\begin{bmatrix} x & y & z & 1 \end{bmatrix} \mathbf{T} = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
t_x & t_y & t_z & 1
\end{bmatrix} = \begin{bmatrix} x + t_x & y + t_y & z + t_z & 1 \end{bmatrix}
$$


### üíª Translation i Python
```python
import numpy as np

# 4x4 translationsmatrix for s√∏jlevektoren (4, 3, 2)
tx, ty, tz = 4, 3, 2
translation_matrix_col = np.array([[1, 0, 0, tx],
                                   [0, 1, 0, ty],
                                   [0, 0, 1, tz],
                                   [0, 0, 0, 1]])

# Punkt der skal translateres (som en eksplicit s√∏jlevektor)
p_col = np.array([[1], [2], [3], [1]])  # 4x1 column vector
T_col = translation_matrix_col @ p_col  # Output vil v√¶re 4x1

print("Translation med s√∏jlevektorer:\n", T_col)

# ‚úî Hvis vi bruger r√¶kkevektorer, transponerer vi blot matricen:

# 4x4 translationsmatrix for r√¶kkevektorer
translation_matrix_row = translation_matrix_col.T

# Translation med (4, 2, 3)
T_row1 = p_col.T @ translation_matrix_row

print("Translation med r√¶kkevektorer:\n", T_row1)

# Vi kunne ogs√• konvertere s√∏jlevektoren til r√¶kkevektor notation direkte
T_row2 = T_col.T 

print("Konverteret til r√¶kkevektor notation:\n", T_row2)
```

---

## 2Ô∏è‚É£ Rotation omkring koordinatakserne
Sidst brugte vi $3 \times 3$ rotationsmatricer til at rotere om koordinatakserne I 3D. Vi kan ogs√• repr√¶sentere dette vha. homogene 4D matricer, her for s√∏jlevektorer:

- **Rotation om \( x \)-aksen**:
  
\[ 
\mathbf{R}_x(\theta)_{\text{s√∏jle}} = 
\begin{bmatrix} 
1 & 0 & 0 & 0 \\ 
0 & \cos \theta & -\sin \theta & 0 \\ 
0 & \sin \theta & \cos \theta & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix} 
\]

- **Rotation om \( y \)-aksen**:
  
\[ 
\mathbf{R}_y(\theta)_{\text{s√∏jle}} = 
\begin{bmatrix} 
\cos \theta & 0 & -\sin \theta & 0 \\ 
0 & 1 & 0 & 0 \\ 
\sin \theta & 0 & \cos \theta & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix} 
\]

- **Rotation om \( z \)-aksen**:
  
\[ 
\mathbf{R}_z(\theta)_{\text{s√∏jle}} = 
\begin{bmatrix} 
\cos \theta & \sin \theta & 0 & 0 \\ 
-\sin \theta & \cos \theta & 0 & 0 \\ 
0 & 0 & 1 & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix} 
\]

Vil du have for r√¶kkevektorer, transponerer du blot matricen:

- **Rotation om \( x \)-aksen**: $\mathbf{R}_x(\theta)_{\text{r√¶kke}} = \mathbf{R}_x(\theta)_{\text{s√∏jle}}^T$
- **Rotation om \( y \)-aksen**: $\mathbf{R}_y(\theta)_{\text{r√¶kke}} = \mathbf{R}_y(\theta)_{\text{s√∏jle}}^T$
- **Rotation om \( z \)-aksen**: $\mathbf{R}_z(\theta)_{\text{r√¶kke}} = \mathbf{R}_z(\theta)_{\text{s√∏jle}}^T$


### üíª Rotation
```python
def rotation_matrix_x(theta):
    """Returnerer en 4x4 rotationsmatrix om x-aksen."""
    c, s = np.cos(theta), np.sin(theta)
    return np.array([[1, 0,  0, 0],
                     [0, c,  -s, 0],
                     [0, s, c, 0],
                     [0, 0,  0, 1]])

# Test rotation om x-aksen
theta = np.radians(30)
Rx = rotation_matrix_x(theta)
print("Rotation om x-aksen:\n", Rx)

# Konverter til r√¶kkevektor notation
Rx_row = Rx.T
```

---

## 3Ô∏è‚É£ Affine Transformationer 
Affine transformationer er transformationer, der kan kombineres af b√•de **line√¶re transformationer** (s√•som rotation, skalering og spejling) og **translationer**.  

### Rotation Om Origo Efterfulgt af Translation
N√•r vi f√∏rst **roterer omkring origo** og derefter **translaterer**, anvender vi transformationerne i denne r√¶kkef√∏lge:  

- **S√∏jlevektorer:**  
  
\[
\mathbf{p}' = \mathbf{T} \mathbf{R} \mathbf{p}
\]

  - Her roteres punktet **f√∏r** det translateres.  
  - Hvis vi √∏nskede at bruge "de samme" matricer, men med r√¶kkevektorer, skulle vi transponere dem.  

- **R√¶kkevektorer:**  
  
\[
\mathbf{p}'^T = \mathbf{p}^T \mathbf{R}^T \mathbf{T}^T
\]

  - Her er Matricerne $T$ og $R$ de samme matricer som i s√∏jletilf√¶ldet. Hvis de er givet som matricer for r√¶kkevektorer, skal de ikke transponeres. Dette er vigtigt!

Denne type transformation bruges n√•r objekter roteres i **world space** og derefter placeres i rummet.  

#### üíª Eksempel

```python
import numpy as np

def translation_matrix(tx, ty, tz):
    """Returnerer en 4x4 translationsmatrix."""
    return np.array([[1, 0, 0, tx],
                     [0, 1, 0, ty],
                     [0, 0, 1, tz],
                     [0, 0, 0, 1]])

def rotation_matrix_x(theta):
    """Returnerer en 4x4 rotationsmatrix om x-aksen."""
    c, s = np.cos(theta), np.sin(theta)
    return np.array([[1, 0,  0, 0],
                     [0, c,  -s, 0],
                     [0, s, c, 0],
                     [0, 0,  0, 1]])

# Definer et punkt i homogene koordinater
P = np.array([1, 2, 3, 1])  # S√∏jlevektor

# Transformationer
T = translation_matrix(5, -2, 3)
R = rotation_matrix_x(np.radians(45))

# Anvend transformationerne
P_transformed = T @ R @ P

print("Transformeret s√∏jlevektor:\n", P_transformed)

# Konverter til r√¶kkevektor notation
P_transformed_row = P.T @ R.T @ T.T    # P.T er ikke n√∏dvendigt

```

Du kan se og interagere med ovenst√•ende transformation her:

<iframe src="https://www.geogebra.org/calculator/vu6tt2s2?embed" width="800" height="600" allowfullscreen style="border: 1px solid #e4e4e4;border-radius: 4px;" frameborder="0"></iframe>

I dette plot illustrerer vi, hvordan en vektor \( P \) transformeres ved hj√¶lp af en rotation efterfulgt af en translation. Vi viser tre vektorer:  

 1. **Den r√∏de vektor (oprindelig vektor)**  
    - Starter i origo \( (0,0,0) \) og peger mod \( (1,2,3) \).  
    - Dette er den oprindelige vektor, f√∏r nogen transformation er anvendt.  

 2. **Den gr√∏nne vektor (roteret vektor)**  
    - Starter i \( (5,-2,3) \) og peger mod \( (6, 1.53553391, 3.70710678) \).  
    - Dette viser, hvordan vektoren ser ud efter at v√¶re blevet **roteret**, men f√∏r translationen har flyttet dens startpunkt.  
    - Retningen er √¶ndret i forhold til den r√∏de vektor p√• grund af rotationen omkring x-aksen.  

 3. **Den bl√• vektor (endeligt transformeret vektor)**  
    - Starter i origo \( (0,0,0) \) og peger mod \( (6, 1.53553391, 3.70710678) \).  
    - Dette er den f√¶rdige transformation, hvor b√•de rotation og translation er anvendt.  
    - Bem√¶rk, at vektoren nu har en ny l√¶ngde og retning i forhold til den r√∏de vektor, hvilket viser effekten af begge transformationer kombineret.  

üîπ **Forskellen mellem den r√∏de og den gr√∏nne vektor** viser, hvordan **rotationen** p√•virker vektorens retning.  
üîπ **Forskellen mellem den gr√∏nne og den bl√• vektor** viser effekten af **translationen**.  

---

### Rotation Omkring Et Vilk√•rligt Punkt
Hvis vi vil **rotere omkring et punkt \( \mathbf{p} \)**, anvender vi en anden strategi:

\[
\mathbf{T}(\mathbf{p}) \mathbf{R} \mathbf{T}(-\mathbf{p})
\]

   - Denne metode sikrer, at rotationen **ikke n√∏dvendigvis sker omkring origo**, men omkring et vilk√•rligt punkt \( \mathbf{p} \).
   - Dette g√¶lder for **s√∏jlevektorer**.

<style type="text/css">
    ol { list-style-type: numbers; }
</style>

1. **\( T(-\mathbf{p}) \) flytter koordinatsystemet, s√• rotationspunktet \( \mathbf{p} \) bliver origo.**  
     - \( T(-\mathbf{p}) \) er en translation, der flytter hele rummet **modsat** af \( \mathbf{p} \), dvs. til \( (0,0,0) \).  

2. **\( R \) roterer vektoren omkring origo.**  
     - \( R \) anvender rotation omkring origo, hvilket er korrekt efter translationen.

3. **\( T(\mathbf{p}) \) flytter koordinatsystemet tilbage.**  
     - \( T(\mathbf{p}) \) gendanner den oprindelige position efter rotationen.

I **homogene koordinater** ser dette s√•dan ud for en s√∏jlevektor \( \mathbf{v} \):

\[
\mathbf{v}' = \mathbf{T}(\mathbf{p}) \mathbf{R} \mathbf{T}(-\mathbf{p}) \mathbf{v}
\]

Hvis vi vil **rotere omkring et punkt \( \mathbf{p} \)** med r√¶kkevektorer, anvender vi en anden strategi:

\[
\mathbf{v}' = \mathbf{v}\,\mathbf{T}(-\mathbf{p})\,\mathbf{R}\,\mathbf{T}(\mathbf{p})
\]

- Denne metode sikrer, at rotationen **ikke n√∏dvendigvis sker omkring origo**, men omkring et vilk√•rligt punkt \( \mathbf{p} \).
- Dette g√¶lder for **r√¶kkevektorer**.

<style type="text/css">
    ol { list-style-type: numbers; }
</style>

1. **\( T(-\mathbf{p}) \) flytter koordinatsystemet, s√• rotationspunktet \( \mathbf{p} \) bliver origo.**  
     - \( T(-\mathbf{p}) \) er en translation, der flytter hele rummet **modsat** af \( \mathbf{p} \), dvs. til \( (0,0,0) \).  

2. **\( R \) roterer vektoren omkring origo.**  
     - \( R \) anvender rotation omkring origo, hvilket er korrekt efter translationen.

3. **\( T(\mathbf{p}) \) flytter koordinatsystemet tilbage.**  
     - \( T(\mathbf{p}) \) gendanner den oprindelige position efter rotationen.

I **homogene koordinater** ser dette s√•dan ud for en r√¶kkevektor \( \mathbf{v} \):

\[
\mathbf{v}' = \mathbf{v}\,\mathbf{T}(-\mathbf{p})\,\mathbf{R}\,\mathbf{T}(\mathbf{p})
\]

Bem√¶rk her at $T$ og $R$ ikke er de helt samme matricer som vi anvendte til s√∏jlevektorerne. De er transponerede, da vi nu arbejder med r√¶kkevektorer. Dette fremg√•r ogs√• af koden nedenfor.


#### üíª Affine: Translation s√• rotation - s√∏jle
```python
### For s√∏jlevektorer

def affine_transform_around_point_col(p, R):
    """Udf√∏rer en transformation omkring et punkt p = (px, py, pz)."""
    T1 = translation_matrix(-p[0], -p[1], -p[2])
    T2 = translation_matrix(p[0], p[1], p[2])
    return T2 @ R @ T1

p = np.array([3, 2, 1])  # Rotationscenter
R = rotation_matrix_x(np.radians(45))
M = affine_transform_around_point_col(p, R)

print("Affine transformation omkring punktet (3,2,1):\n", M)
```

#### üíª Affine: Translation, s√• rotation - r√¶kke
```python
def affine_transform_around_point_row(p, R):
    """Udf√∏rer en transformation omkring et punkt p = (px, py, pz) for r√¶kkevektorer."""
    T1 = translation_matrix(-p[0], -p[1], -p[2]).T      # Bem√¶rk
    T2 = translation_matrix(p[0], p[1], p[2]).T         # Bem√¶rk
    return T1 @ R @ T2

p = np.array([3, 2, 1])  # Rotationscenter
R = rotation_matrix_x(np.radians(45)).T         # Bem√¶rk
M = affine_transform_around_point_row(p, R)

print("Affine transformation omkring punktet (3,2,1) (r√¶kkevektor-metoden):\n", M)
```


## 4Ô∏è‚É£ 3D Transformationer som 4D Homogene Matricer

√òvrige transformationer i 3D kan ogs√• repr√¶senteres som 4x4 homogene matricer:

*   **Skalering langs de kartesiske akser:**

    $$
    \mathbf{S}(k_x, k_y, k_z) = \begin{bmatrix}
    k_x & 0 & 0 & 0 \\
    0 & k_y & 0 & 0 \\
    0 & 0 & k_z & 0 \\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$

*   **Rotation om en vilk√•rlig akse** $\hat{\mathbf{n}} = (n_x, n_y, n_z)$:

    $$
     \mathbf{R}(\hat{\mathbf{n}}, Œ∏) = \begin{bmatrix}
    n_x^2(1 - \cos Œ∏) + \cos Œ∏ & n_xn_y(1 - \cos Œ∏) + n_z\sin Œ∏ & n_xn_z(1 - \cos Œ∏) - n_y\sin Œ∏ & 0 \\
    n_xn_y(1 - \cos Œ∏) - n_z\sin Œ∏ & n_y^2(1 - \cos Œ∏) + \cos Œ∏ & n_yn_z(1 - \cos Œ∏) + n_x\sin Œ∏ & 0 \\
    n_xn_z(1 - \cos Œ∏) + n_y\sin Œ∏ & n_yn_z(1 - \cos Œ∏) - n_x\sin Œ∏ & n_z^2(1 - \cos Œ∏) + \cos Œ∏ & 0 \\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$

*   **Skalering i en vilk√•rlig retning** $\hat{\mathbf{n}}$ **med faktor** $k$:

    $$
     \mathbf{S}(\hat{\mathbf{n}}, k) = \begin{bmatrix}
    1 + (k-1)n_x^2 & (k-1)n_xn_y & (k-1)n_xn_z & 0 \\
    (k-1)n_xn_y & 1 + (k-1)n_y^2 & (k-1)n_yn_z & 0 \\
    (k-1)n_xn_z & (k-1)n_yn_z & 1 + (k-1)n_z^2 & 0 \\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$

*   **Ortografisk projektion p√• et plan med normalvektor** $\hat{\mathbf{n}}$:

    $$
     \mathbf{P}(\hat{\mathbf{n}}) = \begin{bmatrix}
    1 - n_x^2 & -n_xn_y & -n_xn_z & 0 \\
    -n_xn_y & 1 - n_y^2 & -n_yn_z & 0 \\
    -n_xn_z & -n_yn_z & 1 - n_z^2 & 0 \\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$

*   **Refleksion om et plan med normalvektor** $\hat{\mathbf{n}}$:

    $$
     \mathbf{R}(\hat{\mathbf{n}}) = \begin{bmatrix}
    1 - 2n_x^2 & -2n_xn_y & -2n_xn_z & 0 \\
    -2n_xn_y & 1 - 2n_y^2 & -2n_yn_z & 0 \\
    -2n_xn_z & -2n_yn_z & 1 - 2n_z^2 & 0 \\
    0 & 0 & 0 & 1
    \end{bmatrix}
    $$


## Vigtige afsluttende pointer

*   **R√¶kkef√∏lge af Transformationer:** N√•r du bruger homogene matricer, er r√¶kkef√∏lgen, transformationerne anvendes i, afg√∏rende. Hvis du kombinerer flere transformationer, skal du multiplicere matricerne i den korrekte r√¶kkef√∏lge. Hvis du bruger r√¶kkevektorer, udf√∏res transformationerne fra venstre mod h√∏jre. Hvis du bruger s√∏jlevektorer, udf√∏res de fra h√∏jre mod venstre.
*   **To s√¶t transformationsmatricer:** Transformationsmatricerne er ogs√• forskellige om du bruger s√∏jle- eller r√¶kkevektorer.
*   **Affine Transformationer:** Homogene matricer giver dig mulighed for at kombinere line√¶re transformationer (rotation, skalering, shear) med translation, hvilket resulterer i affine transformationer.
*   **Perspektivisk Projektion:** Den fjerde kolonne i en homogen matrix kan bruges til at implementere perspektivisk projektion, hvilket er afg√∏rende for at skabe realistiske 3D-scener.
*   **Points at infinity:** Disse punkter er defineret som v√¶rende p√• formen $(x, y, z, 0)$
*   **Translation 'Sl√•s fra':** w-komponenten i en 4D vektor kan bruges til selektivt at "slukke" for translationsdelen af en 4√ó4 matrix