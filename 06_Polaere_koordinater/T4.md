# Tutorial 4: Cylindriske og Sf√¶riske Koordinater i 3D

N√•r vi bev√¶ger os fra 2D til 3D, udvides det pol√¶re koordinatsystem til to vigtige koordinatsystemer: **cylindriske** og **sf√¶riske koordinater**. Denne tutorial forklarer begge koordinatsystemer med en klar definition, praktiske eksempler, samt illustrerer hvordan de relaterer sig til det kartesiske koordinatsystem.

## Cylindriske koordinater

Cylindriske koordinater er en direkte udvidelse af de 2D pol√¶re koordinater. Systemet best√•r af tre koordinater:

 - **$r$**: Afstanden fra z-aksen (radius).
 - **$\theta$**: Vinklen i xy-planet fra den positive x-akse.
 - **$z$**: H√∏jden langs z-aksen, identisk med kartesisk z-koordinat.

### Lokalisering af punkter:

 - F√∏rst findes positionen $(r, \theta)$ i xy-planet, pr√¶cis som med 2D pol√¶re koordinater.
 - Herefter bev√¶ger man sig op eller ned langs z-aksen.

<p align="center">
    <video class="hover-controls-video" width="800" controls muted poster="../src/T41.png">
        <source src="../src/T41.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
</p>

### Konvertering til og fra kartesiske koordinater:

Fra cylindrisk til kartesisk:

$$
x = r\cos\theta,\quad y = r\sin\theta,\quad z = z
$$

Fra kartesisk til cylindrisk:

$$
r = \sqrt{x^2 + y^2},\quad 
\theta = \text{atan2}(y, x),\quad
z = z
$$

### üíª Konvertering i Python:
```python

import math
import numpy as np

def cylindrical_to_cartesian(r, theta, z):
    """
    Konverterer cylindriske koordinater til kartesiske koordinater.
    
    Parametre:
        r (float): Radial afstand fra z-aksen
        theta (float): Vinkel i radianer i xy-planet
        z (float): H√∏jde langs z-aksen
    
    Returnerer:
        tuple: (x, y, z) i kartesiske koordinater
    """
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    # z √¶ndres ikke
    return x, y, z

def cartesian_to_cylindrical(x, y, z):
    """
    Konverterer kartesiske koordinater til cylindriske koordinater.
    
    Parametre:
        x (float): x-koordinat
        y (float): y-koordinat
        z (float): z-koordinat
    
    Returnerer:
        tuple: (r, theta, z) i cylindriske koordinater
    """
    r = math.sqrt(x*x + y*y)
    theta = math.atan2(y, x)
    # z forbliver u√¶ndret
    return r, theta, z

# Eksempel p√• anvendelse
if __name__ == "__main__":
    # Eksempel p√• punkt i cylindriske koordinater
    r, theta, z = 5, math.radians(45), 10
    
    # Konverter til kartesiske koordinater
    x, y, z_cart = cylindrical_to_cartesian(r, theta, z)
    print(f"Kartesiske koordinater: x={x}, y={y}, z={z_cart}")
    
    # Konverter tilbage til cylindriske koordinater
    r_cyl, theta_cyl, z_cyl = cartesian_to_cylindrical(x, y, z_cart)
    print(f"Tilbage til cylindriske: r={r_cyl}, theta={math.degrees(theta_cyl)}¬∞, z={z_cyl}")

```

### Praktisk anvendelse:
Cylindriske koordinater er is√¶r nyttige ved cylindriske objekter og rotationer om en akse, fx r√∏r, spiraler eller rotationssymmetriske genstande.

## Sf√¶riske koordinater

Sf√¶riske koordinater beskriver punkter ved hj√¶lp af en afstand og to vinkler, hvilket g√∏r dem s√¶rligt nyttige ved kugleformet geometri, eksempelvis planeter, kameraorientering, og lydb√∏lger.

### Matematisk konvention:

 - **$r$ (radius):** Afstanden fra origo til punktet.
 - **$\theta$ (azimut):** Vinkel fra den positive x-akse i xy-planet.
 - **$\phi$ (zenith):** Vinkel m√•lt fra den positive z-akse nedad (0¬∞ peger lodret op, 180¬∞ peger nedad).

### Lokalisering af punkter:
 - Drej f√∏rst vinklen $\theta$ om z-aksen.
 - Drej herefter nedad med vinklen $\phi$ fra z-aksen.
 - Bev√¶g dig til sidst ud langs radius $r$.

<p align="center">
    <video class="hover-controls-video" width="800" controls muted poster="../src/T42.png">
        <source src="../src/T42.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
</p>

### Konvertering mellem sf√¶riske og kartesiske koordinater:

 - **Sf√¶risk til kartesisk:**
  
    - $x = r \sin\phi \cos\theta$
    - $y = r \sin\phi \sin\theta$
    - $z = r \cos\phi$


 - **Kartesisk til sf√¶risk:**

    - $r = \sqrt{x^2 + y^2 + z^2}$
    - $\theta = \text{atan2}(y, x)$
    - $\phi = \arccos\left(\frac{z}{r}\right)$


### üíª Konvertering i Python:
```python
import math
import numpy as np

def spherical_to_cartesian(r, phi, theta):
   """
   Konverterer sf√¶riske koordinater til kartesiske koordinater.
   
   Parametre:
   r (float): Radius (afstand fra origo)
   phi (float): Polar vinkel i radianer (vinkel fra z-aksen)
   theta (float): Azimuthal vinkel i radianer (vinkel i xy-planen)
   
   Returnerer:
   tuple: (x, y, z) i kartesiske koordinater
   """
   x = r * math.sin(phi) * math.cos(theta)
   y = r * math.sin(phi) * math.sin(theta)
   z = r * math.cos(phi)
   return x, y, z

def cartesian_to_spherical(x, y, z):
   """
   Konverterer kartesiske koordinater til sf√¶riske koordinater.
   
   Parametre:
   x (float): x-koordinat
   y (float): y-koordinat
   z (float): z-koordinat
   
   Returnerer:
   tuple: (r, phi, theta) i sf√¶riske koordinater
   """
   r = math.sqrt(x*x + y*y + z*z)
   
   # H√•ndterer specialtilf√¶lde for at undg√• division med nul
   if r == 0:
       return 0, 0, 0
   
   phi = math.acos(z / r)
   theta = math.atan2(y, x)
   
   return r, phi, theta

# Eksempel p√• brug
if __name__ == "__main__":
   # Eksempel punkt i sf√¶riske koordinater
   r, phi, theta = 5, math.pi/4, math.pi/3
   print(f"Sf√¶risk: r={r}, phi={phi} radianer, theta={theta} radianer")
   
   # Konvert√©r til kartesisk
   x, y, z = spherical_to_cartesian(r, phi, theta)
   print(f"Kartesisk: x={x}, y={y}, z={z}")
   
   # Konvert√©r tilbage til sf√¶risk
   r_sph, phi_sph, theta_sph = cartesian_to_spherical(x, y, z)
   print(f"Tilbage til sf√¶risk: r={r_sph}, phi={phi_sph} radianer, theta={theta_sph} radianer")
```

### Videospil-konvention:
I spiludvikling anvendes ofte en anden intuitiv konvention:

 - **$r$ (radius):** Afstanden til punktet.
 - **$h$ (heading):** Horisontal vinkel fra den positive z-akse (fremad/nord).
 - **$p$ (pitch):** Vertikal vinkel fra vandret plan; positiv nedad, negativ opad.

### Konvertering mellem sf√¶riske og kartesiske koordinater (videospil):

 - **Sf√¶risk til kartesisk:**

    - $x = r \cos p \sin h$
    - $y = -r \sin p$
    - $z = r \cos p \cos h$

 - **Kartesisk til sf√¶risk:**

    - $r = \sqrt{x^2 + y^2 + z^2}$
    - $h = \text{atan2}(x, z)$
    - $p = \arcsin\left(-\frac{y}{r}\right)$

Denne konvention er ofte mere intuitiv ved kamerastyring i spil.

### 

```python	
import math
import numpy as np

def spherical_to_cartesian(r, phi, theta):
   """
   Konverterer sf√¶riske koordinater til kartesiske koordinater.
   
   Parametre:
   r (float): Radius (afstand fra origo)
   phi (float): Polar vinkel i radianer (vinkel fra z-aksen)
   theta (float): Azimuthal vinkel i radianer (vinkel i xy-planen)
   
   Returnerer:
   tuple: (x, y, z) i kartesiske koordinater
   """
   x = r * math.sin(phi) * math.cos(theta)
   y = r * math.sin(phi) * math.sin(theta)
   z = r * math.cos(phi)
   return x, y, z

def cartesian_to_spherical(x, y, z):
   """
   Konverterer kartesiske koordinater til sf√¶riske koordinater.
   
   Parametre:
   x (float): x-koordinat
   y (float): y-koordinat
   z (float): z-koordinat
   
   Returnerer:
   tuple: (r, phi, theta) i sf√¶riske koordinater
   """
   r = math.sqrt(x*x + y*y + z*z)
   
   # H√•ndterer specialtilf√¶lde for at undg√• division med nul
   if r == 0:
       return 0, 0, 0
   
   phi = math.acos(z / r)
   theta = math.atan2(y, x)
   
   return r, phi, theta

# Eksempel p√• brug
if __name__ == "__main__":
   # Eksempel punkt i sf√¶riske koordinater
   r, phi, theta = 5, math.pi/4, math.pi/3
   print(f"Sf√¶risk: r={r}, phi={phi} radianer, theta={theta} radianer")
   
   # Konvert√©r til kartesisk
   x, y, z = spherical_to_cartesian(r, phi, theta)
   print(f"Kartesisk: x={x}, y={y}, z={z}")
   
   # Konvert√©r tilbage til sf√¶risk
   r_sph, phi_sph, theta_sph = cartesian_to_spherical(x, y, z)
   print(f"Tilbage til sf√¶risk: r={r_sph}, phi={phi_sph} radianer, theta={theta_sph} radianer")
```

## Aliasing og Gimbal lock i Sf√¶riske Koordinater

Sf√¶riske koordinater har s√¶rlige udfordringer, kaldet aliasing, fordi forskellige koordinater kan beskrive samme punkt:

 - **Aliasing:** Opst√•r grundet periodiciteten af vinkler.
 - **Gimbal lock:** Opst√•r ved pitch-vinkler t√¶t p√• ¬±90¬∞, hvor heading-vinklen mister betydning.

For at undg√• dette anvendes ogs√• her en **kanonisk form** for koordinaterne:

 - Begr√¶nsninger (videospil-konvention):
   - $r \geq 0$
   - $-180^\circ < h \leq 180^\circ$
  - $-90^\circ \leq p \leq 90^\circ$
   - Ved $r = 0$: s√¶t $h = 0$, $p = 0$
   - Ved $|p| = 90^\circ$: s√¶t $h = 0$

### &#x1F4BB; Kanonisering (Python):**
```python
def strict_canonical_spherical(r, h, p):
    """
    F√∏lger strengt den 7-trins algoritme for kanonisk form-konvertering
    som beskrevet i bogen.
    """
    # Konverter til grader for nemmere at f√∏lge algoritmen
    p_deg = math.degrees(p)
    h_deg = math.degrees(h)
    
    # 1. Hvis r=0, s√• s√¶t h=p=0
    if r == 0:
        return 0, 0, 0
        
    # 2. Hvis r<0, s√• neg√©r r, l√¶g 180¬∞ til h, og neg√©r p
    if r < 0:
        r = -r
        h_deg += 180
        p_deg = -p_deg
        
    # 3. Hvis p<-90¬∞, s√• l√¶g 360¬∞ til p indtil p‚â•-90¬∞
    while p_deg < -90:
        p_deg += 360
        
    # 4. Hvis p>270¬∞, s√• tr√¶k 360¬∞ fra p indtil p‚â§270¬∞
    while p_deg > 270:
        p_deg -= 360
        
    # 5. Hvis p>90¬∞, s√• l√¶g 180¬∞ til h og s√¶t p=180¬∞-p
    if p_deg > 90:
        h_deg += 180
        p_deg = 180 - p_deg
        
    # 6. Hvis h‚â§-180¬∞, s√• l√¶g 360¬∞ til h indtil h>-180¬∞
    while h_deg <= -180:
        h_deg += 360
        
    # 7. Hvis h>180¬∞, s√• tr√¶k 360¬∞ fra h indtil h‚â§180¬∞
    while h_deg > 180:
        h_deg -= 360
    
    # Konverter tilbage til radianer
    h = math.radians(h_deg)
    p = math.radians(p_deg)
    
    return r, h, p
```